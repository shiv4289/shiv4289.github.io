---
layout: post
title: MySQL-5.7.4- Change master without stopping slave altogether
date: 2014-04-03 02:21:01 UTC
updated: 2014-04-03 02:21:01 UTC
comments: true
categories:
- mysql
tags:
- mysql
- performance_schema
---

<div dir="ltr" style="text-align: left;" trbidi="on">At MySQL, we have been working on simplifying the failover process  making it faster, more flexible and easier to use. MySQL-5.6 came up  with <a href="http://svenmysql.blogspot.se/2012/10/failover-and-flexible-replication.html" target="_blank">Global Transaction Identifiers (GTID)</a> which was a huge leap in the  direction of easing the failover process hiding the details about  replication logs and positions. With <a href="https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-4.html" target="_blank">MySQL-5.7.4</a>, we are introducing a  new feature that further adds to flexibility and onliness- the user can  only shut down components that he needs to re-configure. <br /><br />What we allow with this new feature is to execute <a href="https://dev.mysql.com/doc/refman/5.7/en/change-master-to.html" target="_blank">CHANGE MASTER TO</a>  command without stopping slave altogether. We realized that stopping  slave altogether is not mandatory in all cases and doing that was more  of a cautious approach to switching master restricting more than whatâ€™s  required at times. <br /><br />Lets dive deep into this to see what can be relaxed here. For this, lets  break the replication process into two modules: <br />M1) Receiver module (concerned with <a href="http://dev.mysql.com/doc/refman/5.7/en/replication-implementation-details.html" target="_blank">IO thread</a>) and <br />M2) Applier module (concerning SQL thread or coordinator and worker  threads, whichever be the case)<br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: justify;"><span style="text-align: left;">We can now divide options under the command CHANGE MASTER TO into  three groups based on</span><span style="text-align: left;">&nbsp;the above classification:&nbsp;</span></div><div class="separator" style="clear: both; text-align: justify;"><span style="text-align: left;"><br /></span></div><div class="separator" style="clear: both; text-align: justify;"><span style="text-align: left;">G1) Options that change a receiver configuration.&nbsp;</span></div><span style="text-align: left;">G2) Options that change an applier configuration.&nbsp;</span><br /><span style="text-align: left;">G3) Options that relate to both (1) and (2).&nbsp;</span><br /><br style="text-align: left;" /><span style="text-align: left;">For the precise division look at the picture below. Note that the illustration takes into account all the CHANGER MASTER TO options present currently (MySQL-5.7.4).&nbsp;</span><br /><div class="separator" style="clear: both; text-align: justify;"><span style="text-align: left;"><br /></span></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-0YsSX_0teRA/U2SQ_bjhjLI/AAAAAAAADDc/L5nY2im2aec/s1600/Page_1.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-0YsSX_0teRA/U2SQ_bjhjLI/AAAAAAAADDc/L5nY2im2aec/s1600/Page_1.JPG" height="350" width="550" /></a></div><br /><br />Note that given its current usage, we could put the MASTER_AUTO_POSITION &nbsp;option under group G1(i.e., receive side). Currently only the receiver  module uses GTID positioning but we foresee that in future it will be  good to allow the applier module to use GTID positioning. We thus keep  the master_auto_position option under group G3 to keep things  future-proof. Worried that obstructs the failover process again like  before? Well that's not a problem as MASTER_AUTO_POSITION is a slave's  configuration that you only set once. Then it affects all future times  that you redirect to a new immediate master. So you don't specify it on  fail-over. <br /><br />With the classifications stated above, we propose a 3-point rule stated as: <br />R1) For CHANGE MASTER TO options under group G1, stop only receiver  module (M1) using the command STOP SLAVE IO_THREAD command. <br />R2) For CHANGE MASTER TO options under group G2, stop only applier  module (M2) using the command STOP SLAVE SQL_THREAD command. <br />R3) For CHANGE MASTER TO options under group G3, stop both receiver (M1)  and <br /><div style="text-align: left;">applier modules (M2) using the command STOP SLAVE. <br /><br /><b><u><i>HOW DOES THIS RULE WORK? </i></u></b><br />Lets explore more about our 3-point rule(R1-R3): <br /><br /><ul style="text-align: left;"><li>Starting with rule R1, we stated that we only need to stop the  receiver thread to change receive options. What happens to the applier  module? Well the applier module keeps applying pending transactions, if any. If you have a  situation where the slave was lagging behind with a lot of transactions  queued into the slave's&nbsp;logs, you can allow the applier module to catch up while you switch  masters or change a configuration on the receive side keeping the master  same.</li><li>Under rule R2, we stated that we can change configuration of applier  module after stopping the applier threads ONLY, receiver module can be  running while you do this. So while you fine-tune your slave applier module the receiver module  keeps reading master's log and copying transactions to the slave's log.  These could then be  applied in-parallel by the slave when the applier module is up and running.</li><li>Under rule R3, you stop both receiver and applier modules. So, this is  analogous to<br /> STOP SLAVE;<br /> CHANGE MASTER TO &lt;master_def&gt;; <br />used before this feature was available. </li></ul></div><br />Worried how relay log purge would be handled now? Well its pretty  simple- Under rules R1 and R2, we do not purge logs implicitly on  executing the CHANGE MASTER command so that the receiver or applier  whichever is running just keeps processing/adding relay logs as it would  do if no replication thread was stopped. <br /><br />Finally note that you need not always look at the figure above to find  which options are allowed which thread being stopped. You just need to  ask yourself if the parameter is related to receiver thread and stop the  concerned thread. And if you go wrong there are error messages to guide  you on the right path. Look at the next section for the usage and the  errors. <br /><br /><b><i><u>EXAMPLES OF USAGE</u></i></b><br /><b><u>example 1</u></b>: <br />Previously, to change master heartbeat period, you would do a<br /><br />STOP SLAVE; <br />CHANGE MASTER TO MASTER_HEARTBEAT_PERIOD= &lt;value&gt;; <br />START SLAVE; <br /><br />Now, with this feature you just have to stop the receiver (io) thread as  heartbeat has nothing to do with the applier thread(s).<br />&nbsp; <br />STOP SLAVE IO_THREAD; <br />CHANGE MASTER TO MASTER_HEARTBEAT_PERIOD= &lt;value&gt;; <br />START SLAVE IO_THREAD; <br /><br />Note that the applier thread keeps executing the transactions in the  relay log while you change the heartbeat period for the master-slave  connection. Likewise, you could do this with all the attributes mentioned in group  G1 in the figure above. <br /><br /><b><u>example 2</u></b>: <br />Similarly, to change applier thread attributes, you just have to stop  the applier threads. <br />So instead of <br /><br />STOP SLAVE; <br />CHANGE MASTER TO MASTER_DELAY=&lt;value&gt;; <br />START SLAVE; <br /><br />it is enough to do the following with this feature. <br /><br />STOP SLAVE SQL_THREAD; <br />CHANGE MASTER TO MASTER_DELAY=&lt;value&gt;; <br />START SLAVE SQL_THREAD; <br /><br />Lastly, if you go wrong there are nicely worded error message to guide  you. So in the first case, if your receiver module is active and you  execute a<br /><br />CHANGE MASTER TO MASTER_HEARTBEAT_PERIOD= &lt;value&gt;;<br /><br />&nbsp;you get an error saying: <br /><blockquote class="tr_bq">This operation cannot be performed with a running slave io thread; run  STOP SLAVE IO_THREAD&nbsp;first.</blockquote><br /><br />and if you forgot changing applier module when it was required, the  server will say:<br /><br /><blockquote class="tr_bq">This operation cannot be performed with a running slave sql thread;  run STOP SLAVE SQL_THREAD first.</blockquote><br /><br />Lastly you still have the error message saying both the threads should  stop appearing only for MASTER_AUTO_POSITION option now:<br />MASTER <br /><blockquote class="tr_bq">This operation cannot be performed with a running slave; run STOP SLAVE  first.</blockquote><br />Lets see some examples once again: <br /><br /><b><u>example 3</u></b>:<br />slave&gt;START SLAVE; <br />slave&gt;CHANGE MASTER TO MASTER_DELAY= 10;<br />ERROR 1900 (HY000): This operation cannot be performed with a running  slave sql thread; run STOP SLAVE SQL_THREAD first<br /><br /><b><u>example 4</u></b>:<br />mysql&gt; CHANGE MASTER TO MASTER_HEARTBEAT_PERIOD= 10; <br />ERROR 1904 (HY000): This operation cannot be performed with a running  slave io thread; run STOP SLAVE IO_THREAD first.<br /><br /><b><u>example 5</u></b>:<br />mysql&gt; CHANGE MASTER TO MASTER_AUTO_POSITION= 0; <br />ERROR 1198 (HY000): This operation cannot be performed with a running  slave; run STOP SLAVE first <br /><br /><b><i><u>SIDE-EFFECTS?</u></i></b><br /><br />While implementing this, we have taken special care to make sure we dont  break anything for a user switching masters like: <br /><br />STOP SLAVE; <br />CHANGE MASTER to &lt;master_def&gt;; <br />START SLAVE. <br /><br />There are absolutely NO side-effects to worry you. Note that as stated  before, CHANGE MASTER TO will not delete relay logs if one of the  receiver or applier thread is running. <br /><br />Try it out and give us your feedback. As always, we look forward to  hearing from you to improve this feature. Enjoy :)<span class="moz-smiley-s1" title=":)"></span></div>
