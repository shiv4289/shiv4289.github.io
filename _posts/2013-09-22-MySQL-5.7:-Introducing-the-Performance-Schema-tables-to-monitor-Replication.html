---
layout: post
title: MySQL 5.7.2- Introducing the Performance Schema tables to monitor Replication 
date: 2013-09-22 11:49:03 UTC
updated: 2013-09-22 11:49:03 UTC
comments: true
categories:
- mysql
tags:
- mysql
- performance_schema
---

<div dir="ltr" style="text-align: left;" trbidi="on"><br /><a href="http://dev.mysql.com/doc/refman/5.6/en/" target="_blank">MySQL-5.6</a>&nbsp;was our best release ever and we are happy to see people praising it. This motivates us to work even harder for our next release. <a href="http://www.oracle.com/us/corporate/press/2020378" target="_blank">MySQL-5.7.2 DMR is out</a> and we have already got a number of MySQL replication features. Below is a list of these features:<br /><br />&nbsp; &nbsp; - <a href="http://geek.rohitkalhans.com/2013/05/mysqlbinlog-idemmpotent-mode.html" target="_blank">mysqlbinlog idempotent mode</a><br />&nbsp; &nbsp; - <a href="http://manishthe.blogspot.com/2013/05/introduction-with-wonderful-and-best.html" target="_blank">mysqlbinlog --rewrite-db option</a><br />&nbsp; &nbsp; - <a href="http://my-replication-life.blogspot.com/2013/09/dump-thread-enhancement.html" target="_blank">Dump thread does not take binary log lock</a><br />&nbsp; &nbsp; - <a href="http://my-replication-life.blogspot.com/2013/09/loss-less-semi-synchronous-replication.html" target="_blank">Lossless semisync</a><br />&nbsp; &nbsp; - <a href="http://binlogtorelaylog.blogspot.com/2013/09/enhancedMTS-configuration.html" target="_blank">intra-schema multi-threaded slave</a><br />&nbsp; &nbsp; - Performance Schema tables for replication monitoring (this post :) )<br /><br />We want to make MySQL-5.7 huge and these are tiny steps towards the same.<br /><br />This post introduces the Performance Schema tables to monitor MySQL replication. You can find the official documentation for the same <a href="http://www.blogger.com/(http://dev.mysql.com/doc/refman/5.7/en/performance-schema-replication-tables.html" target="_blank">here</a>. This post gives a brief overview of these Performance Schema tables in an attempt to prepare you to dive deeper into the details.&nbsp;Please follow <a href="http://shivjijha.blogspot.com/2013/09/Monitoring-Replication-with-the-NEW-performance-schema-tables.html" target="_blank">my second blog post on this topic</a> to know the details on the individual tables.<br /><br /><b><u>Why Performance Schema Tables:</u></b><br /><br />Replication is a delicate module of MySQL and people want to know its status frequently. To monitor the MySQL replication health, we have been using the <a href="http://dev.mysql.com/doc/refman/5.7/en/show-slave-status.html)" target="_blank">SHOW SLAVE STATUS</a>&nbsp;command for long. But replication is growing fast and this static command is not able to match up to people's expectations. <span style="background-color: white;">SHOW SLAVE STATUS does not scale in the sense that there are multiple parts of the slave server: receiver part, applier part, intermediate queues, etc, in cases, multiple instances of each part</span><b style="background-color: #fff2cc; font-style: italic;">.</b> It has 54 fields, as of now, interleaving different information together. It has now reached such a point where we foresee that not having an SQL interface to query exactly what is required from the replication status would make monitoring tedious. So, we decided to have tables to monitor replication and we have put all our tables in the performance_schema database.<br /><br />The motivation behind having tables is:<br /><br /><ul style="text-align: left;"><li>To make it easier to access exactly what is required, through an SQL interface,</li><li>Pieces of data can be assigned to variables and thus used in stored procedures etc,</li><li>Easier testing with SELECT item from Performance Schema tables,</li><li>Split the logically unrelated information into different tables,</li><li>Cross-reference monitoring data seamlessly by joining with other Performance Schema tables, Information_Schema tables etc,</li><li>Easier to extend and</li><li>More flexibility to&nbsp;accommodate&nbsp;a lot of replication information but still be organized and easy to use.</li></ul><br />Additionally, we noted that SHOW SLAVE STATUS used a lot of technical jargons(words like IO, SQL, Relay_log etc). In order to make it easier to monitor replication, we decided to hide these implementation specific details so that it is easier to understand the names. We have tried our best to make it convenient for everyone to understand the names of the tables and the fields.<br /><div style="text-align: left;"><br /><b><u>Why 6 tables? What does each stand for:</u></b><br /><br />The idea is to come up with a better organized and an easy to extend interface. To start with, we have split the information under SHOW SLAVE STATUS into different parts based on:<br /><br /><ol style="text-align: left;"><li>Connection information or execute information</li><li>In each of (1), we further have configuration and status related fields put into different tables.</li></ol><br />Based on the above classifications, we have got four tables:<br /><br /></div><div style="text-align: left;">&nbsp; &nbsp; a) &nbsp; &nbsp;replication_connection_configuration,<br />&nbsp; &nbsp; b) &nbsp; &nbsp;replication_connection_status,<br />&nbsp; &nbsp; c) &nbsp; &nbsp;replication_execute_configuration and<br />&nbsp; &nbsp; d) &nbsp; &nbsp;replication_execute_status<br /><br />Note that all replication applier module status information under (d) would become confusing again and it makes more sense to have them split based on overall stats, coordinator's status or worker's status. So, we have two more tables namely,<br /><br />&nbsp; &nbsp; e) &nbsp; &nbsp;replication_execute_status_by_coordinator and<br />&nbsp; &nbsp; f) &nbsp; &nbsp; replication_execute_status_by_worker.<br /><br />Note that (d) is responsible for showing the overall status of the applier module in replication, (e) relates to the coordinator thread and (f) refers to the worker thread.<br /><br />See the tree diagram below for the basis of division of data into different tables as discussed above:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-xCRi0kjxBM4/Uj3PSvsGEnI/AAAAAAAABy4/Yx0JR3DLXhc/s1600/selecting+the+right+table.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="230" src="http://1.bp.blogspot.com/-xCRi0kjxBM4/Uj3PSvsGEnI/AAAAAAAABy4/Yx0JR3DLXhc/s400/selecting+the+right+table.png" width="400" /></a></div><br />To make it easier to select a table when you have a configuration/status parameter in mind, just ask yourself the following questions:<br /><br /><ul style="text-align: left;"><li>Is it relating to the&nbsp;&nbsp;connection between the slave and its master?</li><li>If yes, you have&nbsp;narrowed down your scope to only (a) and (b).</li><li>If not,&nbsp;the others (c, d, e or f).</li><li>Suppose, the data you are looking for is relating to the connection (not status), now just ask yourself if it is a&nbsp;configuration parameter or relating to the status of connection&nbsp;between slave and its master. And there you are- you know which table to look at.</li><li>If the&nbsp;data you are looking for is relating to the execution of events&nbsp;received at your slave (c, d, e, f) are the tables you have. Now ask yourself the same question. Is this data you need relating to a configuration parameter (c)or relating to the status of execution of events at the slave(d, e or f).</li></ul><br />For those who know the internals and have been using SHOW SLAVE STATUS, the names might look new and it could take a little time to get used to them. So, lets now see how these tables relate to the different replication threads. If you are not familiar with the threads and buffers, you don't really need to understand them. This new replication monitoring interface is designed to make sure you don't have to and hence you can skip this section. If you are familiar with the replication threads and want to understand the tables in terms of threads, you can use the table below to map these tables to the replication thread you want to monitor. But before we move ahead lets revise a couple of things:<br /><br /><ul style="text-align: left;"><li><u style="font-style: italic; font-weight: bold;">IO THREAD:</u>&nbsp;Responsible for the connection between master and slave, also gets queries &nbsp; executed on the master onto the slave.</li><li><u style="font-style: italic; font-weight: bold;">SQL THREAD:</u>&nbsp;Executes the events received from the master at slave.</li><li><u style="font-style: italic; font-weight: bold;">MULTI-THREADED SLAVE (MTS):</u>&nbsp;With only one thread (SQL thread) reading and applying events that are applied by multiple clients concurrently on the master, the slave starts lagging behind the master. In this case, one can chose to opt for MTS. Simply put, we have a buffer (relaylog) on slave server that stores the events executed on the master server. The coordinator thread reads the relaylog and assigns these to worker threads which execute the events assigned to them parallely on the slave. The coordinator thread is the scheduler and the worker threads are responsible for executing the events.</li></ul><br />With the background set, lets now look at the table below to understand the mapping between the Performance Schema tables and the replication threads they monitor.<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-N_4lsdHjQe0/Uj3UG2A324I/AAAAAAAABzU/jcmSpI3ltbk/s1600/relating+the+P_S+tables+to+the+replication+threads.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="192" src="http://4.bp.blogspot.com/-N_4lsdHjQe0/Uj3UG2A324I/AAAAAAAABzU/jcmSpI3ltbk/s640/relating+the+P_S+tables+to+the+replication+threads.png" width="640" /></a></div><br /><br /><br /><br /><br /><br /><br /><br />To end with, it may interest you to note that these Performance Schema tables not only give you an easier way to monitor replication but also allow you to easily obtain all the information available about replication threads and coordinates through a join with the other Performance Schema tables, Information Schema tables, mysql.slave_worker_info etc.<br /><br />Go check it out and let us know if it allows you to know more about the replication status. We want to have your valuable feedback to improve this and add a lot more information to this interface.<br /><br />Want to read more and explore the fields, how-to, what fields etc ? Here is the deep-dive in the <a href="http://shivjijha.blogspot.com/2013/09/Monitoring-Replication-with-the-NEW-performance-schema-tables.html" target="_blank">next post</a> :) Enjoy!<br /><div><br /></div></div></div>
