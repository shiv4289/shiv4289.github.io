---
layout: post
title: MySQL 5.7.2- Monitoring Replication with the Performance Schema tables 
date: 2013-09-23 07:19:05 UTC
updated: 2013-09-23 07:19:05 UTC
comments: true
categories: MySQL
---

<div dir="ltr" style="text-align: left;" trbidi="on">In the <a href="http://shivjijha.blogspot.com/2013/09/Introducing-the-performance-schema-tables-to-monitor-MySQL-replication.html" target="_blank">previous post</a>, we had a look at the Performance Schema tables to monitor MySQL replication. We discussed why these were needed, what advantages they have to offer and what each table stands for. We also did a small exercise to see how one can select a particular table given the data that is needed. We will now dive deeper and look at the individual tables to understand what fields they are made of. We will also go through different scenarios to see how the different pieces of data can be used.<br /><br />Note that these tables report the status/configuration of a replication slave. So, these are empty at the master server or at a standalone server. All the SELECTs we will talk of, are done at the slave. Lets take the tables one by one and go through them.<br /><br /><b><u>REPLICATION_CONNECTION_CONFIGURATION:</u></b><br /><br />This table shows the configuration parameters used by the slave server for connecting to the master server. Lets set up replication with the following <a href="http://dev.mysql.com/doc/refman/5.7/en/change-master-to.html" target="_blank">CHANGE MASTER TO</a> command executed on a slave server. The &nbsp;CHANGE MASTER TO command adds/changes the parameters that the slave server uses for connecting to the master server. To see the definition of all the fields in this table, please visit our <a href="http://dev.mysql.com/doc/refman/5.7/en/replication-connection-configuration-table.html" target="_blank">official documentation</a>.<br /><br /><pre style="font-size: 12px;"><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: black;">change </span><span style="color: blue;">master to </span><span style="color: black;">master_host</span><span style="color: blue;">=</span><span style="color: red;">'127.0.0.1'</span><span style="color: grey;">, </span><span style="color: black;">master_port</span><span style="color: blue;">=</span><span style="color: black;">13000 </span><span style="color: grey;">,</span><span style="color: black;"><br />master_user</span><span style="color: blue;">=</span><span style="color: red;">'rpluser'</span><span style="color: grey;">, </span><span style="color: black;">master_password</span><span style="color: blue;">=</span><span style="color: red;">'secret'</span><span style="color: grey;">, </span><span style="color: black;">master_connect_retry</span><span style="color: blue;">=</span><span style="color: black;">40</span><span style="color: grey;">, </span><span style="color: black;"><br />master_retry_count</span><span style="color: blue;">=</span><span style="color: black;">10</span><span style="color: grey;">, </span><span style="color: black;">master_ssl</span><span style="color: blue;">=</span><span style="color: black;">1</span><span style="color: grey;">, </span><span style="color: black;">master_ssl_verify_server_cert</span><span style="color: blue;">=</span><span style="color: black;">1</span><span style="color: grey;">, </span><span style="color: black;"><br />master_auto_position</span><span style="color: blue;">=</span><span style="color: black;">1</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">; </span></span><span style="color: black;"><br />Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected</span><span style="color: grey;">, </span><span style="color: black;">2 warnings </span><span style="color: grey;">(</span><span style="color: black;">0.51 sec</span><span style="color: grey;">)</span></pre><br />We can now look up the connection parameters set in our table for <i>replication connection configuration</i>. Lets do a SELECT * on this table to see what we get:<br /><br /><span style="background-color: white; color: #38761d;">mysql&gt; select * from performance_schema.replication_connection_configuration\G</span> <br /><pre><span style="background-color: white; color: #38761d; font-size: 12px;">*************************** 1. row ***************************<br />                         HOST: 127.0.0.1<br />                         PORT: 13000<br />                         USER: rpluser<br />            NETWORK_INTERFACE:<br />                AUTO_POSITION: 1<br />                  SSL_ALLOWED: YES<br />                  SSL_CA_FILE:<br />                  SSL_CA_PATH:<br />              SSL_CERTIFICATE:<br />                   SSL_CIPHER:<br />                      SSL_KEY:<br />SSL_VERIFY_SERVER_CERTIFICATE: YES<br />                 SSL_CRL_FILE:<br />                 SSL_CRL_PATH:<br />    CONNECTION_RETRY_INTERVAL: 40<br />       CONNECTION_RETRY_COUNT: 10<br />1 row in set (0.00 sec)</span></pre><br />You can see that the changes made by CHANGE MASTER TO command can be seen in this table. These values are preserved here until the next CHANGE MASTER TO or RESET SLAVE ALL command. A row in this table represents a connection between the slave and its master. Since we have only one master here, we see only one row. If MySQL supported multi-source, then this table would have information about multiple sources- one row per source.<br /><br />Note that a <a href="http://dev.mysql.com/doc/refman/5.7/en/start-slave.html" target="_blank">START SLAVE</a>&nbsp;is not done yet. The CHANGE MASTER TO command makes changes to the internal data structures regarding the connection parameters (if you know the internals, the "active_mi" variable is what I am talking about) and this table just picks up values from this data structure. So, the values shown in the table just reflects the state of the this data structure at the moment the SELECT was done.<br /><br />Lets now move to the next table "replication_connection_status".<br /><br /><b><u>REPLICATION_CONNECTION_STATUS:</u></b><br /><br />This table shows the current status of connection between the slave and its master. Technically, it talks about the IO thread's status. To view the definition of all the fields in this table, please visit our <a href="http://dev.mysql.com/doc/refman/5.7/en/replication-connection-status-table.html" target="_blank">official documentation</a>. Now, we need a START SLAVE because this command establishes the connection between slave and its master. So, lets execute a START SLAVE/ START SLAVE IO_THREAD command followed by a SELECT* from "replication_connection_status" table.<br /><br /><pre><span style="background-color: #f3f3f3; color: black; font-size: 12px;">mysql</span><span style="background-color: #f3f3f3; color: grey; font-size: 12px;">&gt; </span><span style="background-color: #f3f3f3; color: black; font-size: 12px;">start slave</span><span style="color: grey; font-size: 12px;"><span style="background-color: #f3f3f3;">;</span><span style="background-color: white;"> </span></span><span style="color: black; font-size: 12px;">Query OK</span><span style="color: grey; font-size: 12px;">, </span><span style="color: black; font-size: 12px;">0 rows affected </span><span style="color: grey; font-size: 12px;">(</span><span style="color: black; font-size: 12px;">0.05 sec</span><span style="color: grey; font-size: 12px;">)</span></pre><pre><span style="background-color: #f3f3f3; color: grey; font-size: 12px;"><br /></span><span style="color: #274e13;"><span style="font-size: 12px;">mysql&gt; select * from performance_schema.replication_connection_status\G<br />*************************** 1. row ***************************<br />             SOURCE_UUID: 1766a057-10cd-11e3-b06a-0021cc72bfc3<br />               THREAD_ID: 2<br />           SERVICE_STATE: ON<br />RECEIVED_TRANSACTION_SET:<br />       LAST_ERROR_NUMBER: 0<br />      LAST_ERROR_MESSAGE:<br />    LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00</span></span></pre><br />So, we can see from here that, at the moment SELECT was done:<br /><br /><ol><li>The slave was reading from a master with UUID= 1766a057-10cd-11e3-b06a-0021cc72bfc3,</li><li>The thread that handles this connection (IO thread) has an id=2. The thread_id field is very useful if you&nbsp;want to join this table with other Performance Schema/Information Schema tables. As an example,&nbsp;you can join this table with the table performance_schema.threads to extract a lot more information&nbsp;about this connection (IO thread). Likewise, there is a lot more&nbsp;&nbsp;thread-wise statistics you can collect with the&nbsp;other existing Performance Schema tables.&nbsp;Note that there is a bug here &nbsp;but thankfully there is an easy workaround.</li><li>Further, we see that our connection (the IO thread) is ready for service (SERVICE_STATE: ON).&nbsp;</li></ol><div>Note that the service state shows one of (<b><i>ON/OFF/CONNECTING</i></b>):</div><div><ul style="text-align: left;"><li><b><i>ON:</i></b> meaning ready to serve i.e. if there is an event that is executed on master, you can assume &nbsp; &nbsp; &nbsp;that it will be read by the slave via this connection.</li><li><b><i>OFF:</i></b> meaning the connection (IO thread) is not serving i.e. it is not ready to read from the master or killed.</li><li><b><i>CONNECTING</i></b>: meaning the connection (IO thread)is not established yet but the slave is trying to connect.</li></ul></div><div>It is important to note here that the names and semantics of thread_id and service_state is extended to all the status tables and they all mean exactly the same. Hence, going forward lets skip explaining these two columns in the following tables.</div><br />Lets now execute a couple of queries on the master server and see if we can get the set of received transactions on our slave server.<br /><br /><pre style="font-size: 12px;"><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt;</span><span style="color: blue;">create table </span><span style="color: black;">test.t</span><span style="color: grey;">(</span><span style="color: black;">a </span><span style="color: blue;">int primary key</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">);</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected </span><span style="color: grey;">(</span><span style="color: black;">0.61 sec</span><span style="color: grey;">)</span></pre><pre style="font-size: 12px;"><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt;</span><span style="color: blue;">insert into </span><span style="color: black;">test.t </span><span style="color: blue;">values</span><span style="color: grey;">(</span><span style="color: black;">1</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">);</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">1 row affected </span><span style="color: grey;">(</span><span style="color: black;">0.06 sec</span><span style="color: grey;">)</span></pre><br />Lets turn back to our slave server and see what the field "received_transaction_set" has.<br /><br /><pre><span style="font-size: 12px;"><span style="color: #274e13;">mysql&gt; select received_transaction_set from performance_schema.replication_connection_status\G<br />*************************** 1. row ***************************<br />RECEIVED_TRANSACTION_SET: 1766a057-10cd-11e3-b06a-0021cc72bfc3:1-4<br />1 row in set (0.00 sec)</span></span></pre><pre><span style="color: grey;"><span style="font-size: 12px;"><br /></span></span></pre>Lets now cause an error in the connection (IO thread) and look at the error related fields in this table. To cause an error in the connection, we will provide a wrong password in our CHANGE MASTER TO command.<br /><br /><br /><pre><span style="background-color: #f3f3f3;"><span style="color: black; font-size: 12px;">mysql</span><span style="color: grey; font-size: 12px;">&gt;</span><span style="color: black; font-size: 12px;">stop slave</span></span><span style="color: grey; font-size: 12px;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black; font-size: 12px;">Query OK</span><span style="color: grey; font-size: 12px;">, </span><span style="color: black; font-size: 12px;">0 rows affected </span><span style="color: grey; font-size: 12px;">(</span><span style="color: black; font-size: 12px;">0.10 sec</span><span style="color: grey; font-size: 12px;">)<br /></span><span style="background-color: #f3f3f3;"><span style="color: black; font-size: 12px;">mysql</span><span style="color: grey; font-size: 12px;">&gt;</span><span style="color: black; font-size: 12px;">change </span><span style="color: blue; font-size: 12px;">master to </span><span style="color: black; font-size: 12px;">master_password</span><span style="color: blue; font-size: 12px;">=</span><span style="color: red; font-size: 12px;">'abcd'</span></span><span style="color: grey; font-size: 12px;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black; font-size: 12px;">Query OK</span><span style="color: grey; font-size: 12px;">, </span><span style="color: black; font-size: 12px;">0 rows affected</span><span style="color: grey; font-size: 12px;">, </span><span style="color: black; font-size: 12px;">2 warnings </span><span style="color: grey; font-size: 12px;">(</span><span style="color: black; font-size: 12px;">0.29 sec</span><span style="color: grey; font-size: 12px;">)<br /><br /></span><pre style="font-size: 12px;"><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: black;">start slave</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">;</span></span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected </span><span style="color: grey;">(</span><span style="color: black;">0.05 sec</span><span style="color: grey;">)<br /></span></pre></pre><pre></pre><br /><pre style="font-size: 12px;"><span style="color: #274e13;">mysql&gt; select last_error_number, last_error_message, last_error_timestamp from <br />performance_schema.replication_connection_status\G</span></pre><span style="color: #274e13; font-size: 12px;">*************************** 1. row ***************************&nbsp;</span><span style="color: #274e13;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><br /><span style="font-size: 12px;"><span style="color: #274e13;">&nbsp; LAST_ERROR_NUMBER: 1045 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></span><br /><pre style="font-size: 12px;"><span style="color: #274e13;">&nbsp;&nbsp;LAST_ERROR_MESSAGE:&nbsp;error connecting to master&nbsp;</span><span style="color: #274e13; font-family: 'Courier New', Courier, monospace; font-size: x-small;">'rpluser@127.0.0.1:13000' -&nbsp;</span><span style="color: #274e13;">retry-time: 40 retries: 2</span><span style="color: #274e13;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">LAST_ERROR_TIMESTAMP: 0000-00-00  <br />1 row in set (0.00 sec)</span></pre><br /><br />The names and semantics of the error related fields(number, message and timestamp) are again exactly same across all the tables, wherever applicable. Hence, going ahead, lets skip monitoring error related fields in the following tables.<br /><br />Lets now clean-up the error we caused to move ahead and work with other tables.<br /><br /><pre style="font-size: 12px;"><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: black;">stop slave</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected </span><span style="color: grey;">(</span><span style="color: black;">0.06 sec</span><span style="color: grey;">)<br /></span><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: black;">change </span><span style="color: blue;">master to </span><span style="color: black;">master_password</span><span style="color: blue;">=</span><span style="color: red;">'secret'</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected</span><span style="color: grey;">, </span><span style="color: black;">2 warnings </span><span style="color: grey;">(</span><span style="color: black;">0.25 sec</span><span style="color: grey;">)<br /></span><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: black;">start slave</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected </span><span style="color: grey;">(</span><span style="color: black;">0.08 sec</span><span style="color: grey;">)</span></pre><br /><pre style="font-size: 12px;"><span style="color: #274e13;">mysql&gt; select last_error_number, last_error_message, last_error_timestamp from <br />performance_schema.replication_connection_status\G</span></pre><span style="color: #274e13; font-size: 12px;">*************************** 1. row ***************************&nbsp;</span><span style="color: #274e13;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><br /><span style="font-size: 12px;"><span style="color: #274e13;">&nbsp; LAST_ERROR_NUMBER: 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></span><br /><pre style="font-size: 12px;"><span style="color: #274e13;">&nbsp;&nbsp;LAST_ERROR_MESSAGE:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />LAST_ERROR_TIMESTAMP: 0000-00-00  <br />1 row in set (0.00 sec)&nbsp;</span></pre><br />Great! We are done with monitoring the connection specific parameters between a slave and its master. Lets now move to the other half of replication module- execution of events received from the master on the slave server.<br /><br /><b><u>REPLICATION_EXECUTE_CONFIGURATION/STATUS:</u></b><br /><br /><span style="background-color: white; font-family: Helvetica, Arial, sans-serif; font-size: 13.63636302947998px; line-height: 24.545454025268555px;">This table shows the configuration parameters that affect execution of transactions by the slave server. Parameters stored in the table can be changed with the&nbsp;</span><a class="link" href="http://dev.mysql.com/doc/refman/5.7/en/change-master-to.html" style="background-color: white; border: 0px; color: #015a84; font-family: Helvetica, Arial, sans-serif; font-size: 13.63636302947998px; line-height: 24.545454025268555px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;" title="13.4.2.1. CHANGE MASTER TO Syntax"><code class="literal" style="border: 0px; color: #026789; font-family: 'Courier New', Courier, fixed, monospace; font-size: 13.63636302947998px; font-weight: bold; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">CHANGE MASTER TO</code></a><span style="background-color: white; font-family: Helvetica, Arial, sans-serif; font-size: 13.63636302947998px; line-height: 24.545454025268555px;">&nbsp;command.&nbsp;</span>Lets setup a delayed replication now and see how the same can be read from the tables<i> replication execute configuration</i>.<br /><br /><br /><pre style="font-size: 12px;"><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: black;">stop slave</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected </span><span style="color: grey;">(</span><span style="color: black;">0.11 sec</span><span style="color: grey;">)<br /></span><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: black;">change </span><span style="color: blue;">master to </span><span style="color: black;">master_delay</span><span style="color: blue;">=</span><span style="color: black;">150</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected </span><span style="color: grey;">(</span><span style="color: black;">0.29 sec</span><span style="color: grey;">)<br /></span><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: black;">start slave</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected </span><span style="color: grey;">(</span><span style="color: black;">0.06 sec</span><span style="color: grey;">)<br /></span></pre><br /><span style="color: #274e13;">mysql&gt; select desired_delay from performance_schema.replication_execute_configuration\G</span><br /><pre style="font-size: 12px;"><span style="color: #274e13;">*************************** 1. row ***************************</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">DESIRED_DELAY: 150<br />1 row in set (0.00 sec)</span></pre><br />Lets now execute an event at our master to see if the event is executed at the slave or not.<br /><br /><pre style="font-size: 12px;"><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: blue;">insert into </span><span style="color: black;">test.t </span><span style="color: blue;">values</span><span style="color: grey;">(</span><span style="color: black;">1</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">);</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">1 row affected </span><span style="color: grey;">(</span><span style="color: black;">0.06 sec</span><span style="color: grey;">)</span></pre><br />Lets move to slave and make sure our slave has not elapsed the 150 second delay yet.<br /><br /><pre style="font-size: 12px;"><span style="color: #274e13;">mysql&gt; select remaining_delay from performance_schema.replication_execute_status\G</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">*************************** 1. row ***************************</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">REMAINING_DELAY: 147<br />1 row in set (0.00 sec)</span></pre><pre style="font-size: 12px;"><span style="color: grey;"><br /></span></pre>Now we should be able to see that although the insert(2) is received at slave it is not executed yet. The last time we saw our received_transaction_set (before insert(2)), it was 1766a057-10cd-11e3-b06a-0021cc72bfc3:1-4. So insert(2) should be assigned a GTID 1766a057-10cd-11e3-b06a-0021cc72bfc3:5.<br /><br /><span style="color: #274e13;">mysql&gt; select received_transaction_set from performance_schema.replication_connection_status\G</span><br /><pre style="font-size: 12px;"><span style="color: #274e13;">*************************** 1. row ***************************</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">RECEIVED_TRANSACTION_SET: 1766a057-10cd-11e3-b06a-0021cc72bfc3:5<br />1 row in set (0.00 sec)</span></pre><br />Ok, we have received the event. Now lets see if this insert(2) with GTID 1766a057-10cd-11e3-b06a-0021cc72bfc3:5 is executed yet.<br /><br /><span style="color: #274e13;">mysql&gt; select @@global.gtid_executed\G</span><br /><pre style="font-size: 12px;"><span style="color: #274e13;">*************************** 1. row ***************************</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">@@global.gtid_executed: 1766a057-10cd-11e3-b06a-0021cc72bfc3:1-4<br />1 row in set (0.00 sec)</span></pre><br />Lets now wait until, our delay is elapsed.<br /><br /><pre style="font-size: 12px;"><span style="color: #274e13;">mysql&gt; select remaining_delay from performance_schema.replication_execute_status\G</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">*************************** 1. row ***************************</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">REMAINING_DELAY: 0<br />1 row in set (0.00 sec)</span></pre><br />And check if the insert(2) has been executed.<br /><br /><span style="color: #274e13;">mysql&gt; select @@global.gtid_executed\G</span><br /><span style="color: #274e13;">*************************** 1. row ***************************</span><br /><span style="color: #274e13;">@@global.gtid_executed: 1766a057-10cd-11e3-b06a-0021cc72bfc3:1-5</span><br /><span style="color: #274e13;">1 row in set (0.00 sec)</span><br /><br />Executed. Great!<br /><br />Before going ahead to have a look at the other goodies in store, lets revise a couple of things:<br /><ul style="text-align: left;"><li style="border: none; margin: 0px 0px 0.25em; padding: 0px;"><u style="font-style: italic; font-weight: bold;">SQL THREAD:</u>&nbsp;Executes the events received from the master at slave.</li><li style="border: none; margin: 0px 0px 0.25em; padding: 0px;"><u style="font-style: italic; font-weight: bold;">MULTI-THREADED SLAVE (MTS):</u>&nbsp;With only one thread (SQL thread) reading and applying events that are applied by multiple clients concurrently on the master, the slave starts lagging behind the master. In this case, one can chose to opt for MTS. Simply put, we have a buffer (relaylog) on slave server that stores the events executed on the master server. The coordinator thread reads the relaylog and assigns these to worker threads which execute the events assigned to them parallely on the slave. The coordinator thread is the scheduler and the worker threads are responsible for executing the events.</li></ul><br /><b><u>REPLICATION_EXECUTE_STATUS_BY_COORDINATOR:</u></b><br /><br />This table is used in two ways depending on whether the slave is operating with one applier (MTS disabled) or multiple appliers executing events in parallel(MTS enabled). When operating with one applier, this table reports the status of this applier. When multiple appliers, the same table reports the status of the scheduler (coordinator thread). Lets explore the single applier use case.<br /><br /><span style="color: #274e13;">mysql&gt; select * from performance_schema.replication_execute_status_by_coordinator\G</span><br /><pre style="font-size: 12px;"><span style="color: #274e13;">*************************** 1. row ***************************</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; THREAD_ID: 13<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SERVICE_STATE: ON<br />&nbsp;&nbsp; LAST_ERROR_NUMBER: 0<br />&nbsp;&nbsp;LAST_ERROR_MESSAGE:<br />LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00<br />1 row in set (0.00 sec)</span></pre><br />We see that the applier's (SQL thread) id is 13 and it is alive (SERVICE_STATE: ON). For now there are only two states that we show- ON/OFF. The semantics of error fields are exactly similar to the explanations earlier. Hence we skip them here.<br /><br />The Multiple applier case (MTS enabled) is similar except that this table will show the scheduler's (coordinator) thread id. Hence we will skip the explanations and move to the next table. To read more about this table, please visit our<a href="http://dev.mysql.com/doc/refman/5.7/en/replication-execute-status-by-coordinator-table.html" target="_blank"> official documentation for this table</a>.<br /><br /><b><u>REPLICATION_EXECUTE_STATUS_BY_WORKER (Single Applier Case):</u></b><br /><br />When the slave server is operating in the single applier mode, lets see what the table replication_execute_status_by_worker shows us. Conceptually, we don't have a scheduler and multiple appliers. so the table should be empty.<br /><br /><span style="color: #274e13;">mysql&gt; select * from performance_schema.replication_execute_status_by_worker\G</span><br /><span style="color: #274e13;">Empty set (0.00 sec)</span><br /><br />And it is empty :)<br /><br /><b><u>REPLICATION_EXECUTE_STATUS_BY_WORKER (Multiple Appliers Case):</u></b><br /><br />Lets now set up our slave to use multiple appliers (MTS enabled) and then see how we can monitor the replication status concerned with our scheduler and appliers (coordinator and worker threads). Lets call our multiple appliers "worker".<br /><br /><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: black;">stop slave</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected </span><span style="color: grey;">(</span><span style="color: black;">0.10 sec</span><span style="color: grey;">)</span><br /><pre style="font-size: 12px;"><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: blue;">SET </span><span style="color: black;">GLOBAL slave_parallel_workers</span><span style="color: blue;">=</span><span style="color: black;">2</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected </span><span style="color: grey;">(</span><span style="color: black;">0.00 sec</span><span style="color: grey;">)</span></pre><br />Note that a START SLAVE is necessary to have the workers ready for action. Just setting slave_parallel_workers=2, doesn’t spawn the 2 workers.<br /><br /><pre style="font-size: 12px;"><span style="background-color: #f3f3f3;"><span style="color: black;">mysql</span><span style="color: grey;">&gt; </span><span style="color: black;">start slave</span></span><span style="color: grey;"><span style="background-color: #f3f3f3;">;</span> </span><span style="color: black;">Query OK</span><span style="color: grey;">, </span><span style="color: black;">0 rows affected</span><span style="color: grey;">, </span><span style="color: black;">1 warning </span><span style="color: grey;">(</span><span style="color: black;">0.14 sec</span><span style="color: grey;">)</span></pre><br /><span style="color: #274e13;">mysql&gt; select * from performance_schema.replication_execute_status_by_worker\G</span><br /><pre style="font-size: 12px;"><span style="color: #274e13;">*************************** 1. row ***************************</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORKER_ID: 0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THREAD_ID: 16<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_STATE: ON<br />LAST_SEEN_TRANSACTION:<br />&nbsp;&nbsp;&nbsp;&nbsp;LAST_ERROR_NUMBER: 0<br />&nbsp;&nbsp; LAST_ERROR_MESSAGE:<br /> LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">*************************** 2. row ***************************</span></pre><pre style="font-size: 12px;"><span style="color: #274e13;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORKER_ID: 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THREAD_ID: 17<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_STATE: ON<br />LAST_SEEN_TRANSACTION:<br />&nbsp;&nbsp;&nbsp;&nbsp;LAST_ERROR_NUMBER: 0<br />&nbsp;&nbsp; LAST_ERROR_MESSAGE:<br /> LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00<br />2 rows in set (0.00 sec)</span></pre><br />So, we see that we have two rows to represent the two workers. The worker_id field here is same as the id field in slave_worker_info table, so you can again join the two tables to know more about a worker thread. The service_state(ON/OFF) has nothing new to add.<br />The interesting parts here are:<br /><ol style="text-align: left;"><li>You get the per worker error. So, if two of your workers have errored out in a group, you can identify both the errors as opposed to only one through SHOW SLAVE STATUS.</li><li>last_seen_transaction is the new field we have added to help detect MTS failures better. This helps you find the GTID of all the transactions being executed by the all the workers at the moment&nbsp;the error happened. These values are preserved in case of an error and in the idle state of the worker after executing the transactions.</li></ol>To read more about this table and field-wise descriptions, please visit our <a href="http://dev.mysql.com/doc/refman/5.7/en/replication-execute-status-by-worker-table.html" target="_blank">official documentation for this table</a>.<br /><br /><b><u>CONCLUDING REMARKS:</u></b><br /><br />The goal of this post was to help you&nbsp;familiarize&nbsp;with the Performance Schema tables relating to replication. Please try out this new interface for monitoring MySQL replication and let us know your feedback. To read more on these Performance Schema tables, you can visit the <a href="http://on-mysql-replication.blogspot.com/2013/09/feature-preview-mysql-multi-source-replication.html" target="_blank">blog on multisource replication by Rith</a>. These Performance Schema tables look really powerful with multisource replication. The motive behind this feature was to make it easier to monitor the health and performance of MySQL replication. We hope this new interface to monitor MySQL replication makes our user's life easier.</div>
